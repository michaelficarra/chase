\section{Haskell Chase Implementation}

	The goal of the implementation of the chase is to deterministically find
	all possible outcomes of the chase. It does this by forking and taking all
	paths when encountering a disjunct rather than nondeterministically
	choosing one disjunct to satisfy.

	The results from the attempts to satisfy each disjunct are returned as a
	list. The returned list will not contain an entry for runs that return no
	model, and will merge lists returned from runs that themselves encountered
	a disjunct. The lazy evaluation of Haskell allows a user to access members
	of the returned list even though some chase runs have not returned a value.

	Appendix B contains the chase-running portions of the implementation.

	\subsection{Operation}

	The first step of the chase implementation is to verify that each formula
	of the given theory is a geometric logic formula. If a formula $\varphi$ is
	not a geometric logic formula, the chase tries to coerce it into one using
	the following algorithm:

	\begin{algorithm}[H]
	\DontPrintSemicolon
	\Switch{$\varphi$}{
		\Case{$\neg\alpha$}{
			\If{$\alpha$ is in positive existential form}{
				$\varphi$ is replaced with $\alpha \to \bot$ \;
			}
			\lElse{error \;}
		}
		\Other{
			\If{$\varphi$ is in positive existential form}{
				$\varphi$ is replaced with $\top \to \varphi$ \;
			}
			\lElse{error \;}
		}
	}
	\end{algorithm}

	After the input verification and coercion step, the $chase$ function sorts
	the input formul{\ae} by the number of disjuncts on the right side of the
	implication. This step will cause each fork of the algorithm to finish in
	less time, as they are likely to halt before forking yet again.

	Once the input formul{\ae} are sorted, the $chase$ function begins
	processing a \emph{pending} list, which is initially populated with a
	single model that has an empty domain and no facts. In the special case
	where $chase$ is run on an empty list, an empty list of models is returned.

	For each \emph{pending} model, each formula is evaluated to see if it holds
	in the model for all environments.  If an envionment is found that does not
	satisfy the model, the model and environment in which the formula did not
	hold is passed to the $satisfy$ function, along with the formula that needs
	to be satisfied.  The list of models returned from $satisfy$ is merged into
	the \emph{pending} list, and the result of running $chase$ on the new
	\emph{pending} list is returned.  If, however, the model holds for all
	formul{\ae} in the theory and all possible associated environments, it is
	concatenated with the result of running the chase on the rest of the models
	in the \emph{pending} list.

	The $satisfy$ function performs a pattern match on the type of formula
	given. Assuming $satisfy$ is given a model $\mathbb{M}$, an environment
	$\lambda$, and a formula $\varphi$, $satisfy$ will behave as outlined
	in the fllowing algorithm.

	\begin{algorithm}[H]
	\DontPrintSemicolon
	\TitleOfAlgo{satisfy :: Model $\to$ Environment $\to$ Formula $\to$ [Model]}
	return \Switch{$\varphi$}{
		\lCase{$\top$}{return a list containing $\mathbb{M}$} \;
		\lCase{$\bot$}{return an empty list} \;
		\lCase{$x=y$}{return a list containing $quotient(\mathbb{M})$} \;
		\lCase{$\alpha \vee \beta$}{return $satisfy(\alpha) \cup satisfy(\beta)$} \;
		\Case{$\alpha \wedge \beta$}{
			create an empty list $r$ \;
			\ForEach{model $m$ in $satisfy(\alpha)$}{
				union $r$ with $satisfy(\beta)$ \;
			}
			return $r$ \;
		}
		\Case{$\alpha \to \beta$}{
			\lIf{$\mathbb{M}_\lambda \models \alpha$}{return $satisfy(\beta)$ \;}
			\lElse{return an empty list \;}
		}
		\Case{$R[\vec x]$}{
			define a new model $\mathbb{N}$ where $|\mathbb{N}| = |\mathbb{M}|$ \;
			add a new element $\omega$ to $|\mathbb{N}|$ \;
			\lForAll{$P_\mathbb{M}$}{$P_\mathbb{N} = P_\mathbb{M}$ \;}
			define $R_{\mathbb{N}}[x_0 \ldots x_n]$ as $R_{\mathbb{M}}[\lambda(x_0) \ldots \lambda(x_n)]$ \;
			\ForEach{$v \in \vec x$}{
				\lIf{$v \not\in \lambda$}{
					$\lambda$ becomes $\lambda_{v \mapsto \omega}$ \;
				}
			}
			return a list containing $\mathbb{N}$ \;
		}
		\Case{$\exists\ \vec x : \alpha$}{
			\lIf{$\vec x = \emptyset$}{ recurse on $\alpha$ } \;
			\eIf{$|\mathbb{M}| \ne \emptyset$ and $\exists\ v' \in |\mathbb{M}| : (\lambda' = \lambda_{x_0 \mapsto v'}$ and $\mathbb{M} \models_{\lambda'} \alpha)$}{
				return a list containing $\mathbb{M}$ \;
			}{
				define a new model $\mathbb{N}$ where $|\mathbb{N}| = |\mathbb{M}|$ \;
				add an element $\omega$ to $|\mathbb{N}|$ such that $\omega \not\in |\mathbb{N}|$ \;
				\lForAll{$R_\mathbb{M}$}{$R_\mathbb{N} = R_\mathbb{M}$ \;}
				define $\kappa = \lambda_{x_0 \mapsto \omega}$ \;
				using model $\mathbb{N}$ and environment $\kappa$, return $satisfy(\exists\ \{x_1 \ldots x_n\} : \alpha)$ \;
			}
		}
	}
	\end{algorithm}

	\subsection{Input Format}

		Input to the parser must be in a form parsable by the following
		context-free grammar. Terminals are denoted by a {\tt monospace style}
		and nonterminals are denoted by an $oblique style$. The greek letter
		$\varepsilon$ matches a zero-length list of tokens. Patterns that match
		non-literal terminals are defined in the table following the grammar.

		\begin{tabular}{ll}
		$program$ & :    $\varepsilon$ \\
		{} & $\mid$      $exprList$ $optNEWLINE$ \\
		\\

		$exprList$ & :   $expr$ \\
		{} & $\mid$      $exprList$ \tt{NEWLINE} $expr$ \\
		\\

		$expr$ & :       \tt{TAUTOLOGY} \\
		{} & $\mid$      \tt{CONTRADICTION} \\
		{} & $\mid$      $expr$ \tt{OR} $expr$ \\
		{} & $\mid$      $expr$ \tt{AND} $expr$ \\
		{} & $\mid$      \tt{NOT} $expr$ \\
		{} & $\mid$      $expr$ \tt{->} $expr$ \\
		{} & $\mid$      \tt{->} $expr$ \\
		{} & $\mid$      $atomic$ \\
		{} & $\mid$      \tt{VARIABLE EQ VARIABLE} \\
		{} & $\mid$      \tt{FOR\_ALL} $argList$ $optCOLON$ $expr$ \\
		{} & $\mid$      \tt{THERE\_EXISTS} $argList$ $optCOLON$ $expr$ \\
		{} & $\mid$      \tt{(} $expr$ \tt{)} \\
		{} & $\mid$      \tt{[} $expr$ \tt{]} \\
		\\

		$atomic$ & :     \tt{PREDICATE} $index$ \\
		\\

		$index$ & :      \tt{(} $argList$ \tt{)} \\
		{} & $\mid$      \tt{[} $argList$ \tt{]} \\
		\\

		$argList$ & :    $arg$ \\
		{} & $\mid$      $argList$ \tt{,} $arg$ \\
		\\

		$arg$ & :        \tt{VARIABLE} \\
		\\

		$optCOLON$ & :   $\varepsilon$ \\
		{} & $\mid$      \tt{:} \\
		\\

		$optNEWLINE$ & : $\varepsilon$ \\
		{} & $\mid$      \tt{NEWLINE} \\
		\end{tabular}

		{\tt \begin{tabular}{|l|l|}
			\hline
			\textbf{Input Pattern} & \textbf{Terminal} \\
			\hline
			|                    & OR  \\
			\&                   & AND \\
			!                    & NOT \\
			=                    & EQ  \\
			$[$Tt$]$autology     & TAUTOLOGY \\
			$[$Cc$]$ontradiction & CONTRADICTION \\
			$[\backslash$r$\backslash$n$]$+ & NEWLINE \\
			$[$a-z$][$A-Za-z0-9\_'$]$* & VARIABLE \\
			$[$A-Z$][$A-Za-z0-9\_'$]$* & PREDICATE \\
			For$[$Aa$]$ll        & FOR\_ALL \\
			Exists               & THERE\_EXISTS \\
			\hline
		\end{tabular} }

		Comments are removed at the lexical analysis step and have no effect on
		the input to the parser.  Single-line comments begin with either a hash
		({\tt \#}) or double-dash ({\tt --}). Multiline comments begin with
		{\tt /*} and are terminated by {\tt */}.

	\subsection{Options}

		\subsubsection{I/O}

		When no options are given to the executable output by Haskell, it
		expects input from stdin and outputs models in a human-readable format
		to stdout. To take input from a file instead, pass the executable the
		{\tt -i} or {\tt --input} option followed by the filename.

		To output models to numbered files in a directory, pass the {\tt -o} or
		{\tt --output} option along with an optional directory name. The given
		directory does not have to exist. If the output directory is omitted,
		it defaults to ``{\tt ./models}".

		\subsubsection{Tracing}

		\textbf{not yet implemented}

	\subsection{Future Considerations}
