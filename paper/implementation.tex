\section{Haskell Chase Implementation}

	The goal of the implementation of the chase is to deterministically find
	all possible outcomes of the chase. It does this by forking and taking all
	paths when encountering a disjunct rather than nondeterministically
	choosing one disjunct to satisfy.

	The results from the attempts to satisfy each disjunct are returned as a
	list. The returned list will not contain an entry for runs that return no
	model, and will merge lists returned from runs that themselves encountered
	a disjunct. The lazy evaluation of Haskell allows a user to access members
	of the returned list even though some chase runs have not returned a value.

	Appendix B contains the chase-running portions of the implementation.

	\subsection{Operation}

	The first step of the chase implementation is to make sure that each formula
	of the given theory can be represented as a geometric logic formula. If a formula $\varphi$ can
	not be coerced to a geometric logic formula, the chase tries to coerce it into one using
	the following algorithm:

	\begin{algorithm}[H]
	\DontPrintSemicolon
	\Switch{$\varphi$}{
		\Case{$\neg\alpha$}{
			\If{$\alpha$ is in positive existential form}{
				$\varphi$ is replaced with $\alpha \to \bot$ \;
			}
			\lElse{error \;}
		}
		\Other{
			\If{$\varphi$ is in positive existential form}{
				$\varphi$ is replaced with $\top \to \varphi$ \;
			}
			\lElse{error \;}
		}
	}
	\end{algorithm}

	The chase function then sorts the input formul{\ae} by the number of
	disjunctions on the right side of the implication. it allows branches to
	terminate without growing to an unnecessarily (and possibly infinitely)
	large size. This step will cause each branch of the algorithm to finish in
	less time, as they are likely to halt before branching yet again. The
	formul{\ae} are not sorted purely by absolute number of disjunctions on the
	right side, but by whether there are zero, one, or many disjunctions. This
	is done to avoid unnecessary re-ordering for no gain because formul{\ae}
	with no disjunctions or only a single disjunct on the right side are more
	likely to cause a branch to stop growing than one with many disjunctions.
	Likewise, formul{\ae} with zero disjunctions are more likely to cause a
	branch to halt than those with one or more disjunctions.

	Once the input formul{\ae} are sorted, the $chase$ function begins
	processing a \emph{pending} list, which is initially populated with a
	single model that has an empty domain and no facts.

	For each \emph{pending} model, each formula is evaluated to see if it holds
	in the model for all environments. If an envionment is found that does not
	satisfy the model, the model and environment in which the formula did not
	hold is passed to the $satisfy$ function, along with the formula that needs
	to be satisfied. The list of models returned from $satisfy$ is merged into
	the \emph{pending} list, and the result of running $chase$ on the new
	\emph{pending} list is returned. If, however, the model holds for all
	formul{\ae} in the theory and all possible associated environments, it is
	concatenated with the result of running the chase on the rest of the models
	in the \emph{pending} list.

	The $satisfy$ function performs a pattern match on the type of formula
	given. Assuming $satisfy$ is given a model $\mathbb{M}$, an environment
	$\lambda$, and a formula $\varphi$, $satisfy$ will behave as outlined
	in the following algorithm.

	\begin{algorithm}[H]
	\DontPrintSemicolon
	\TitleOfAlgo{satisfy :: Model $\to$ Environment $\to$ Formula $\to$ [Model]}
	return \Switch{$\varphi$}{
		\lCase{$\top$}{return a list containing $\mathbb{M}$} \;
		\lCase{$\bot$}{return an empty list} \;
		\lCase{$x=y$}{return a list containing $quotient(\mathbb{M})$} \;
		\lCase{$\alpha \vee \beta$}{return $satisfy(\alpha) \cup satisfy(\beta)$} \;
		\Case{$\alpha \wedge \beta$}{
			create an empty list $r$ \;
			\ForEach{model $m$ in $satisfy(\alpha)$}{
				union $r$ with $satisfy(\beta)$ \;
			}
			return $r$ \;
		}
		\Case{$\alpha \to \beta$}{
			\lIf{$\mathbb{M}_\lambda \models \alpha$}{return $satisfy(\beta)$ \;}
			\lElse{return an empty list \;}
		}
		\Case{$R[\vec x]$}{
			define a new model $\mathbb{N}$ where $|\mathbb{N}| = |\mathbb{M}|$ \;
			add a new member $\omega$ to $|\mathbb{N}|$ \;
			\lForAll{$P_\mathbb{M}$}{$P_\mathbb{N} = P_\mathbb{M}$ \;}
			define $R_{\mathbb{N}}[x_0 \ldots x_n]$ as $R_{\mathbb{M}}[\lambda(x_0) \ldots \lambda(x_n)]$ \;
			\ForEach{$v \in \vec x$}{
				\lIf{$v \not\in \lambda$}{
					$\lambda$ becomes $\lambda_{v \mapsto \omega}$ \;
				}
			}
			return a list containing $\mathbb{N}$ \;
		}
		\Case{$\exists\ \vec x : \alpha$}{
			\lIf{$\vec x = \emptyset$}{ recurse on $\alpha$ } \;
			\eIf{$|\mathbb{M}| \ne \emptyset$ and $\exists\ v' \in |\mathbb{M}| : (\lambda' = \lambda_{x_0 \mapsto v'}$ and $\mathbb{M} \models_{\lambda'} \alpha)$}{
				return a list containing $\mathbb{M}$ \;
			}{
				define a new model $\mathbb{N}$ where $|\mathbb{N}| = |\mathbb{M}|$ \;
				add a member $\omega$ to $|\mathbb{N}|$ such that $\omega \not\in |\mathbb{N}|$ \;
				\lForAll{$R_\mathbb{M}$}{$R_\mathbb{N} = R_\mathbb{M}$ \;}
				define $\kappa = \lambda_{x_0 \mapsto \omega}$ \;
				using model $\mathbb{N}$ and environment $\kappa$, return $satisfy(\exists\ \{x_1 \ldots x_n\} : \alpha)$ \;
			}
		}
	}
	\end{algorithm}

	\subsection{Input Format}

		Input to the parser must be in a form parsable by the following
		context-free grammar. Terminals are denoted by a {\tt monospace style}
		and nonterminals are denoted by an $oblique style$. The greek letter
		$\varepsilon$ matches a zero-length list of tokens. Patterns that match
		non-literal terminals are defined in the table following the grammar.

		\begin{tabular}{ll}
		$program$ & :    $\varepsilon$ \\
		{} & $\mid$      $exprList$ $optNEWLINE$ \\
		\\

		$exprList$ & :   $expr$ \\
		{} & $\mid$      $exprList$ \tt{NEWLINE} $expr$ \\
		\\

		$expr$ & :       \tt{TAUTOLOGY} \\
		{} & $\mid$      \tt{CONTRADICTION} \\
		{} & $\mid$      $expr$ \tt{OR} $expr$ \\
		{} & $\mid$      $expr$ \tt{AND} $expr$ \\
		{} & $\mid$      \tt{NOT} $expr$ \\
		{} & $\mid$      $expr$ \tt{->} $expr$ \\
		{} & $\mid$      \tt{->} $expr$ \\
		{} & $\mid$      $atomic$ \\
		{} & $\mid$      \tt{VARIABLE EQ VARIABLE} \\
		{} & $\mid$      \tt{FOR\_ALL} $argList$ $optCOLON$ $expr$ \\
		{} & $\mid$      \tt{THERE\_EXISTS} $argList$ $optCOLON$ $expr$ \\
		{} & $\mid$      \tt{(} $expr$ \tt{)} \\
		{} & $\mid$      \tt{[} $expr$ \tt{]} \\
		\\

		$atomic$ & :     \tt{PREDICATE} $index$ \\
		\\

		$index$ & :      \tt{(} $argList$ \tt{)} \\
		{} & $\mid$      \tt{[} $argList$ \tt{]} \\
		\\

		$argList$ & :    $arg$ \\
		{} & $\mid$      $argList$ \tt{,} $arg$ \\
		\\

		$arg$ & :        \tt{VARIABLE} \\
		\\

		$optCOLON$ & :   $\varepsilon$ \\
		{} & $\mid$      \tt{:} \\
		\\

		$optNEWLINE$ & : $\varepsilon$ \\
		{} & $\mid$      \tt{NEWLINE} \\
		\end{tabular}

		{\tt \begin{tabular}{|l|l|}
			\hline
			\textbf{Input Pattern} & \textbf{Terminal} \\
			\hline
			|                    & OR  \\
			\&                   & AND \\
			!                    & NOT \\
			=                    & EQ  \\
			$[$Tt$]$autology     & TAUTOLOGY \\
			$[$Cc$]$ontradiction & CONTRADICTION \\
			$[\backslash$r$\backslash$n$]$+ & NEWLINE \\
			$[$a-z$][$A-Za-z0-9\_'$]$* & VARIABLE \\
			$[$A-Z$][$A-Za-z0-9\_'$]$* & PREDICATE \\
			For$[$Aa$]$ll        & FOR\_ALL \\
			Exists               & THERE\_EXISTS \\
			\hline
		\end{tabular} }

		Comments are removed at the lexical analysis step and have no effect on
		the input to the parser.  Single-line comments begin with either a hash
		({\tt \#}) or double-dash ({\tt --}). Multiline comments begin with
		{\tt /*} and are terminated by {\tt */}.

	\subsection{Options}

		\subsubsection{I/O}

		When no options are given to the executable output by Haskell, it
		expects input from stdin and outputs models in a human-readable format
		to stdout. To take input from a file instead, pass the executable the
		{\tt -i} or {\tt --input} option followed by the filename.

		To output models to numbered files in a directory, pass the {\tt -o} or
		{\tt --output} option along with an optional directory name. The given
		directory does not have to exist. If the output directory is omitted,
		it defaults to ``{\tt ./models}".

		Using the {\tt -o} or {\tt --output} options will change the selection
		for output format to a machine-readable format. To switch ouput formats
		at any time, pass the {\tt -h} or {\tt -m} flags for human-readable and
		machine-readable formats respectively.

		\subsubsection{Tracing}

		\textbf{not yet implemented}

	\subsection{Future Considerations}

		This section details areas of possible improvement/development that
		were unable to be explored during the timeframe allotted for the
		project.

		\subsubsection{Better Data Structures}

			This project was started with no knowledge of the most desirable
			implementation language, Haskell. Because of this, some
			less-than-optimal data structures were used to hold data that
			should really be in a Data.Map or Data.Set. One such example of this
			is with the truth table contained in relations. This truth table
			should probably be implemented as a Data.Map. Also, instead of
			Domains being a list of DomainMember, it would probably be better
			if a Domain was a Data.Set.

		\subsubsection{Broader use of the Maybe Monad}

		\subsubsection{Advanced Rewriters / Simplifiers}

			\textbf{talk about purple book and a reverse pullquants}
