\section{The Chase}

	\textbf{ what does it really generate? any superset of this set is also jointly minimal... }

	The \emph{chase} is a function that, when given a geometric theory, will
	generate a model in the set of jointly minimal models for that theory. More
	specifically, if $\mathcal{U}$ is the set of all models obtained from an
	execution of the chase over a geometric theory $T$, for any model
	$\mathbb{M}$ such that $\mathbb{M} \models T$, there is a homomorphism from
	some model $\mathbb{U} \in \mathcal{U}$ to $\mathbb{M}$.

	There are three types of runs of the chase:
	\begin{itemize}
	\item a set of jointly minimal models is found in finite time
	\item an empty result is found in finite time
	\item an infinite run with possible return dependent on implementation
	\end{itemize}

	Verifying the minimality of a model or the joint minimality of a set of
	models requires checking if a homomorphism exists from the minimal model(s)
	to each of the infinite set of all models that satisfy the theory, assuming
	the theory is satisfiable. It may not at first seem obvious that generating
	a minimal model would be a computable task, but it will be show that the
	chase is able to do this, and it will be proven that the models it returns
	during successful runs are in fact members of (a/the?) set of jointly
	minimal models.

	Geometric logic formul{\ae} are used by the chase because they have some
	useful properties and are natural expressions of some common applications
	that can take advantage of minimal models. Geometric formul{\ae} are
	implications of positive-existential formul{\ae}, which have the useful
	property that, when adding any relations or domain members to a model that
	satisfies a positive-existential formula, the model will always satisfy the
	formula. This is particularly helpful when trying to create a model that
	satisfies all formul{\ae} in a geometric theory.

	\newtheorem{minimality-theorems}{Theorem}

	\begin{theorem}
		A geometric theory $T$ is satisfiable if and only if there is an
		infinite run, given disjunct and binding choice is fair, or there
		is a chase run of $T$ that returns a non-empty result.
	\end{theorem}

	\begin{proof}
		
	\end{proof}

	\begin{theorem}
		Let $\mathcal{M}$ be the set of models returned from all successful
		runs of the chase over a geometric theory $T$. For any model
		$\mathbb{N}$ such that $\mathbb{N} \models T$, there is a model
		$\mathbb{M} \in \mathcal{M}$ such that $\mathbb{M} \preceq
		\mathbb{N}$. $\mathcal{M}$ is jointly minimal.
	\end{theorem}

	\begin{proof}
		
	\end{proof}

	\subsection{Algorithm}

		The chase starts with an input theory $T$ and a model $\mathbb{M}$ that
		has an empty domain and an empty set of facts.

		\begin{algorithm}[H]
		\DontPrintSemicolon
		\TitleOfAlgo{The Chase}
		\While{$\exists$ a formula $\sigma \in T$ such that $\mathbb{M} \not\models \sigma$}{
			choose formula $\sigma \in T$ such that $\mathbb{M} \not\models \sigma$ \;
			split this formula into the left and right sides of its implication, $\alpha$ and $\beta$ \;
			\If{$\beta$ is a contradiction}{halt with a failure \;}
			a binding $\lambda$ is chosen such that $\mathbb{M} \models_\lambda \alpha$ \;
			\If{$\beta$ contains a disjunction}{choose a disjunct and assign it to $\beta$ \;}
			\ForEach{free variable not in the domain of $\lambda$}{add a new domain member to the domain \;}
			\ForEach{new domain element $e$ and the variable $v$ for which it was added}{redefine $\lambda$ as $\lambda_{v \mapsto e}$ \;}
			\ForEach{atomic $R$}{replace each variable $v$ with $\lambda(v)$ and add it to the model \;}
		}
		halt with result $\mathbb{M}$ \;
		\end{algorithm}

	\subsection{Examples}

		Define $\Sigma$ as the following geometric theory.

		\begin{eqnarray}
			\label{eqn:chase1}
			\top    &  \to  &  \exists\ x,y : R(x,y)                             \\
			\label{eqn:chase2}
			R(x,y)  &  \to  &  (\exists\ z : Q(x,z)) \vee P                      \\
			\label{eqn:chase3}
			Q(x,y)  &  \to  &  (\exists\ z : R(x,z)) \vee (\exists\ z : R(z,y))  \\
			\label{eqn:chase4}
			P       &  \to  &  \bot
		\end{eqnarray}

		The following three chase runs show the different types of results
		depending on which disjunct the algorithm attempts to satisfy when a
		disjunction is encountered.

		\begin{enumerate}
		\item A non-empty result in finite time:

			\begin{tabular}{lllllll}
				$\emptyset$ & $\mapsto$ & \{ & $a,b$   & $|$ & $R(a,b)$         & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c$ & $|$ & $R(a,b), Q(a,c)$ & \}
			\end{tabular}

			Since the left side of \eqref{eqn:chase1} is always satisfied, but its
			right side is not, domain members $a$ and $b$ and fact $R(a,b)$ are
			added to the initially empty model to satisfy \eqref{eqn:chase1}. The
			left side of \eqref{eqn:chase2} holds, but the right side does not, so
			one of the disjuncts $\exists\ z : Q(x,z)$ or $P(x)$ is chosen to
			be satisfied. Assuming the left operand is chosen, $x$ will already
			have been assigned to $a$ and a new domain member $c$ and a new
			fact $Q(a,c)$ will be added to satisfy \eqref{eqn:chase2}. With the
			current model, all rules hold under any environment. Therefore,
			this model is minimal.

		\item An empty result in finite time:

			\begin{tabular}{lllllll}
				$\emptyset$ & $\mapsto$ & \{ & $a,b$   & $|$ & $R(a,b)$               & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c$ & $|$ & $R(a,b), P(a,c)$       & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c$ & $|$ & $R(a,b), P(a,c), \bot$ & \} \\
				{}          & $\mapsto$ & \multicolumn{5}{l}{ $\varepsilon$ }
			\end{tabular}

			Again, domain members $a$ and $c$ and fact $R(a,b)$ are added to
			the initial model to satisfy \eqref{eqn:chase1}. This time, when
			attempting to satisfy \eqref{eqn:chase2}, the right side is chosen and
			$P$ is added to the set of facts. After adding this new fact, rule
			\eqref{eqn:chase4} no longer holds; its left side is satisfied, but its
			right side does not hold for all of the bindings for which it is
			satisfied. When we attempt to satisfy the right side of
			\eqref{eqn:chase4}, it is found to be a contradiction and therefore
			unsatisfiable. Since this model can never satisfy this theory, the
			chase fails.

		\item An infinite run:

			\begin{tabular}{lllllll}
				$\emptyset$ & $\mapsto$ & \{ & $a,b$        & $|$ & $R(a,b)$                                 & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c$      & $|$ & $R(a,b), Q(a,c)$                         & \} \\
				{}          & $\mapsto$ & \{ & $a,\ldots,d$ & $|$ & $R(a,b), Q(a,c), R(d,c)$                 & \} \\
				{}          & $\mapsto$ & \{ & $a,\ldots,e$ & $|$ & $R(a,b), Q(a,c), R(d,c), Q(d,e)$         & \} \\
				{}          & $\mapsto$ & \{ & $a,\ldots,f$ & $|$ & $R(a,b), Q(a,c), R(d,c), Q(d,e), R(f,e)$ & \} \\
				{}          & $\mapsto$ & \multicolumn{5}{l}{ $\ldots$ }
			\end{tabular}

			Like in the example above that returned a non-empty, finite result,
			the first two steps add domain members $a$, $b$, and $c$ and facts
			$R(a,b)$ and $Q(a,c)$. The left side of the implication in
			\eqref{eqn:chase3} now holds, but the right side does not. In order to
			make the right side hold, one of the disjuncts needs to be
			satisfied. If the right disjunct is chosen, a new domain member $d$
			and a new relation $R(d,c)$ will be added. This will cause the
			left side of the implication in \eqref{eqn:chase2} to hold for $R(d,c)$,
			but the right side will not hold for the same binding. $Q(d,e)$ will
			be added, and this loop will continue indefinitely unless a
			different disjunct is chosen in \eqref{eqn:chase2} or \eqref{eqn:chase3}.

		\end{enumerate}

	\subsection{History}

		In \cite{FKMP02} \emph{Data Exchange: Semantics and Query Answering},
		Fagin et. al. first introduce a chase algorithm. The version they
		defined disallows disjunctions and, because of that, is limited in its
		utility. Input formul{\ae} without disjunctions are not as expressive
		as geometric formul{\ae} and have less applications. It is, however,
		naturally deterministic.

		The chase was originally used in data exchange. As Fagin et al. states,
		``Data exchange is the problem of taking data structured under a source
		schema and creating an instance of a target schema that reflects the
		source data as accurately as possible". The solution to the stated
		problem was to find a minimal model. In theories without disjunction, a
		single minimal model exists that has a homomorphism to any other model
		that satisfies the theory.

		\textbf{ expand }

	\subsection{Computational Complexity}

		\textbf{ write }
