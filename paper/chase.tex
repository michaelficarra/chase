\section{The Chase}

	The \emph{chase} is a function that, when given a gemoetric theory, will
	generate a set of jointly minimal models for that theory. More
	specifically, if $\mathcal{U}$ is the set of all models obtained from an
	execution of the chase over a geometric theory $T$, for any model
	$\mathbb{M}$ such that $\mathbb{M} \models T$, there is a homomorphism from
	some model $\mathbb{U} \in \mathcal{U}$ to $\mathbb{M}$.

	Geometric logic formul{\ae} are used by the chase because they have the
	useful property where adding any relations or domain members to a model
	that satisfies a geometric logic formula will never cause the formula to no
	longer be satisified. This is particularly helpful when trying to create a
	model that satisifies all formul{\ae} in a geometric theory.

	There are three types of runs of the chase:
	\begin{itemize}
	\item a non-empty result in finite time
	\item an empty result in finite time
	\item an infinite run, with possible return dependent on implementation
	\end{itemize}

	\subsection{Algorithm}

		The chase algorithm begins by defining an empty list of models to
		return $\mathcal{D}$ and a list of pending models $\mathcal{P}$
		containing a model with an empty domain and an empty set of facts. A
		single input is provided to the chase: the geometric theory $\Sigma$.

		Before anything else, the chase algorithm sorts $\Sigma$ by the
		number of disjunctions on the right side of each formula's implication.
		Formul{\ae} with zero disjunctions will be ordered first, followed by
		those with one disjunction, and finally those with more than one
		disjunction. Within each sorting classification, formul{\ae} should
		remain in their original order.

		For every model $\mathbb{M} \in \mathcal{P}$, the chase loops through
		every formula $\sigma \in \Sigma$. For any $\sigma$ and environment
		$\lambda$ such that $\mathbb{M} \not\models_\lambda \sigma$,
		$\mathbb{M}$ has domain members and facts added to it \textbf{as
		described in <algorithm below>}. If $\mathbb{M} \models \Sigma$,
		instead remove $\mathbb{M}$ from $\mathcal{P}$ and add it to
		$\mathcal{D}$.

		\textbf{algorithm for how to make model satisfy a formula}

		Finally, the chase algorithm returns $\mathcal{D}$, a list of jointly
		minimal models for its input theory $\Sigma$.

	\subsection{Examples}

		Define $\Sigma$ as the following geometric theory.

		\begin{eqnarray}
			\top    &  \to  &  \exists\ y,z : R[y,z]                             \\
			R[x,w]  &  \to  &  (\exists\ y : Q[x,y]) \vee (\exists\ z : P[x,z])  \\
			Q[u,v]  &  \to  &  (\exists\ z : R[u,z]) \vee (\exists\ z : R[z,w])  \\
			P[u,v]  &  \to  &  \bot
		\end{eqnarray}

		The following three chase runs show the different types of results
		depending on which disjunct the algorithm attempts to satisfy when a
		disjunction is encountered.

		\begin{enumerate}
		\item A non-empty result in finite time:

			\begin{tabular}{lllllll}
				$\emptyset$ & $\mapsto$ & \{ & $a,b$   & $|$ & $R[a,b]$         & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c$ & $|$ & $R[a,b], Q[a,c]$ & \} \\
			\end{tabular}

			Since the left side of \textbf{(1)} is always satisfied, but its
			right side is not, domain members $a$ and $b$ and fact $R[a,b]$
			are added to the initially empty model to satisfy \textbf{(1)}. The
			left side of \textbf{(2)} holds, but the right side does not, so
			one of the disjuncts $\exists\ y : Q[x,y]$ or $\exists\ z: P[x,z]$
			is chosen to be satisfied. Assuming the left operand is chosen, $x$
			will already have been assigned to $a$ and a new domain member $c$
			and a new fact $Q[a,c]$ will be added to satisfy \textbf{(2)}. With
			the current model, all rules hold under any environment. Therefore,
			this model is in the set of jointly minimal models for our theory.

			\textbf{This is worded for a simpleton. Is that okay?}

		\item An empty result in finite time:

			\begin{tabular}{lllllll}
				$\emptyset$ & $\mapsto$ & \{ & $a,b$   & $|$ & $R[a,b]$               & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c$ & $|$ & $R[a,b], P[a,c]$       & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c$ & $|$ & $R[a,b], P[a,c], \bot$ & \} \\
				{}          & $\mapsto$ & \multicolumn{5}{l}{ $\varepsilon$ } \\
			\end{tabular}

			Again, domain members $a$ and $c$ and fact $R[a,b]$ are added to
			the initial model to satisfy \textbf{(1)}.  This time, when
			attempting to satisfy \textbf{(2)}, the right side is chosen and
			$P[a,c]$ is added to the set of facts. After adding this new fact,
			rule \textbf{(4)} no longer holds; its left side is satisfied, but
			its right side does not hold for all of the bindings for which it
			is satisfied. When we attempt to satisfy the right side of
			\textbf{(4)}, it is found to be a contradiction and therefore
			unsatisfiable. Since this model can never satisfy this theory, the
			chase fails.

		\item An infinite run:

			\begin{tabular}{lllllll}
				$\emptyset$ & $\mapsto$ & \{ & $a,b$         & $|$ & $R[a,b]$                                 & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c$       & $|$ & $R[a,b], Q[a,c]$                         & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c,d$     & $|$ & $R[a,b], Q[a,c], R[d,c]$                 & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c,d,e$   & $|$ & $R[a,b], Q[a,c], R[d,c], Q[d,e]$         & \} \\
				{}          & $\mapsto$ & \{ & $a,b,c,d,e,f$ & $|$ & $R[a,b], Q[a,c], R[d,c], Q[d,e], R[f,e]$ & \} \\
				{}          & $\mapsto$ & \multicolumn{5}{l}{ $\ldots$ } \\
			\end{tabular}

			Like in the example above that returned a non-empty, finite result,
			the first two steps add domain members $a$, $b$, and $c$ and facts
			$R[a,b]$ and $Q[a,c]$.

			\textbf{it would never run infinitely like this... ask me why}

		\end{enumerate}
