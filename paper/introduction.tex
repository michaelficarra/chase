\section{Introduction}

	\textbf{ remove this? }

	This document details work done for a Major Qualifying Project at Worcester
	Polytechnic Institute by Michael Ficarra in partial fulfillment of the
	requirements for a Bachelor of Science degree in Computer Science.

	\subsection{Goals}

		The two main goals of this Major Qualifying Project are:

		\begin{enumerate}
		\item to implement an algorithm known as ``the chase" accurately
		and with a well-defined, usable interface, and
		\item to use the chase implementation for a real-world
		application: generating models used in analysis of a specific protocol
		\end{enumerate}

		Secondary goals include implementing various optimizations and
		integrating the chase implementation into a program that can take
		advantage of the functionality it provides.

	\subsection{The Chase}

		\textbf{ this whole section needs some expanding still }

		\emph{The chase} is an algorithm used to find jointly minimal models
		(see \ref{sec:technical_background.minimal_models}) for a set of
		geometric logic formul{\ae}. Many common real-world problems can be
		expressed as a set of geometric logic formul{\ae} (see
		\ref{sec:technical_background.geometric_logic}). When these problems
		have an unbounded scope of possible solutions, the chase can be used to
		find the possible solutions that are interesting. This allows
		researchers to go through only models that represent a large set of
		models rather than testing each of the infinite number of models
		separately.

		To generate these jointly minimal models, the chase begins with a model
		$\mathbb{M}$ that has an empty domain and no facts. The chase goes
		through each formula $\sigma$ in the geometric theory $T$ such that
		$\mathbb{M} \not\models \sigma$ and alters $\mathbb{M}$ so that
		$\mathbb{M} \models \sigma$. Geometric formul{\ae} are implications of
		positive-existential formul{\ae} (see \ref{}), which have the useful
		property in that adding elements/facts to a model that satisfies a
		positive-existential formula will never cause the model to no longer
		satisfy that formula. Because of this, the chase can keep adding to the
		model until all formul{\ae} are satisfied. The resulting model is in a
		set of jointly minimal models.

		The chase is nondeterministic over disjunctions. When a disjunction is
		encountered, a disjunct is chosen and the chase continues until it
		encounters another disjunct.

		We will see in section \ref{sec:implementation} that, in a Haskell
		implementation of the chase, both disjuncts can be satisfied by forking
		the chase and returning a list containing the concatenation of the
		lists returned by the forks. In this way, we can deterministically
		calculate a set of jointly minimal models by using a naturally
		nondeterministic algorithm.

		Cryptographic protocol analysis is the particular application that is
		explored in section \ref{sec:application.strand_spaces}. In this
		application, protocols are modeled in the strand space formalism. Each
		role of every participant in a legal run of the protocol is modeled as
		a strand. The roles of a special participant that does not obey the
		rules of the protocol are called adversary strands (see
		\ref{sec:application.the_adversary}). These adversary strands consist
		of a series of nodes that send/receive messages to/from regular strands
		while manipulating those messages. Because the positions and actions of
		adversary strands are variable, there exists a large number of possible
		runs of a single protocol. It is prohibitive to test all of these to
		find if they break assumptions made about the properties of the
		protocol. The runs of this protocol can be represented as a geometric
		theory and passed to the chase to find minimal models. When minimal
		models are found, they can describe nearly all interesting ways that
		the adversaries can interact with regular strands. These models can
		then be analysed in a finite amount of time.
