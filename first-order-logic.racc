/* vim: set filetype=racc : */

class FirstOrderLogic

prechigh
	nonassoc NOT
	left MULTIPLY DIVIDE
	left ADD SUBTRACT
	right EQ
preclow

token FACTS RULES CHASE
token LT GT GTE LTE NE EQ
token PLUS MINUS MULTIPLY DIVIDE OR AND NOT
token BRACE_OPEN BRACE_CLOSE PAREN_OPEN PAREN_CLOSE
token FOR_ALL THERE_EXISTS EMPTY_SET
token COLON COMMA SEMICOLON IMPLIES
token PREDICATE IDENTIFIER
token NEWLINE

options no_result_var

start program

rule

program:
	/* nothing */             { Program.new }
	| statementList           { Program.new *val.first; }
	;

statementList:
	statement semicolonOrNewline                    { val.pop; val }
	| statementList statement semicolonOrNewline    { val.pop; val.first.push val.last }
	;

statement:
	/* factDefinitionStatement */
	FACTS IDENTIFIER COLON optNEWLINE factList
	{ FactDefinitionStatement.new( val[1], FactList.new(*val.last) ) }
	| /* ruleDefinitionStatement */
	RULES IDENTIFIER COLON optNEWLINE BRACE_OPEN optNEWLINE ruleList optNEWLINE BRACE_CLOSE
	{ RuleDefinitionStatement.new( val[1], RuleList.new(*val[6]) ) }
	| /* chaseStatement */
	CHASE identifierList                      { ChaseStatement.new *val.last }
	;

factList:
	EMPTY_SET                                 { [] }
	| BRACE_OPEN predicateList BRACE_CLOSE    { val[1] }
	;

predicateList:
	predicate                                 { val }
	| predicateList predicate                 { val.first.push val.last }
	;

identifierList:
	IDENTIFIER                                { val }
	| identifierList COMMA IDENTIFIER         { val.first.push val.last }
	;

ruleList:
	rule                                      { val }
	| ruleList commaOrNewline rule            { val.first.push val.last }
	;

rule:
	existentialQuantifier                     { val.first }
	| universalQuantifier                     { val.first }
	;

existentialQuantifier:
	THERE_EXISTS optCOLON predicateExpression    { ExistentialQuantifier.new val.first, val.last }
	;

universalQuantifier:
	FOR_ALL optCOLON universalQuantifierBody     { UniversalQuantifier.new val.first, val.last }
	;

universalQuantifierBody:
	universalQuantifier                          { val.first }
	existentialQuantifier                        { val.first }
	| predicateExpression                        { val.first }
	| /* predicateImplication */
	predicateExpression IMPLIES expression       { PredicateImplication.new val.first, val.last }
	;

expression:
	predicateExpression                                            { val.first }
	| terminalExpression                                           { val.first }
	;

predicateExpression:
	predicate                                                      { val.first }
	| optNOT PAREN_OPEN predicateExpression PAREN_CLOSE            { val[2].not if val[0]; val[2] }
	| predicateExpression predicateOperator predicateExpression    { PredicateExpression.new val[1], val.first, val.last }
	;

predicate:
	PREDICATE                 { Predicate.new val.first[:symbol], val.first[:terminals] }
	| NOT predicate           { val[1].not; val[1] }
	;

terminalExpression:
	terminal                                                       { val.first }
	| optNOT PAREN_OPEN terminalExpression PAREN_CLOSE             { val[2].not if val[0]; val[2] }
	| terminalExpression terminalOperator terminalExpression       { TerminalExpression.new val[1], val.first, val.last }
	;

terminal:
	IDENTIFIER                { Terminal.new val.first }
	| NOT terminal            { val[1].not; val[1] }
	;

predicateOperator:
    AND                       { @@operators[:AND] }
	| OR                      { @@operators[:OR] }
	;

terminalOperator:
	LT                        { @@operators[:LT] }
	| GT                      { @@operators[:GT] }
	| LTE                     { @@operators[:LTE] }
	| GTE                     { @@operators[:GTE] }
	| NE                      { @@operators[:NE] }
	| EQ                      { @@operators[:EQ] }
	| MULTIPLY                { @@operators[:MULTIPLY] }
	| DIVIDE                  { @@operators[:DIVIDE] }
	| PLUS                    { @@operators[:PLUS] }
	| MINUS                   { @@operators[:MINUS] }
	;

optNOT:     /* nothing */ { false } | NOT     { true } ;
optCOLON:   /* nothing */ { false } | COLON   { true } ;
optNEWLINE: /* nothing */ { false } | NEWLINE { true } ;

commaOrNewline:
	NEWLINE                   { val.first }
	| COMMA optNEWLINE        { val.first }
	;

semicolonOrNewline:
	NEWLINE                   { '' }
	| SEMICOLON optNEWLINE    { val.first }
	;

end

---- header
	require 'first-order-logic.rex.rb'
	Dir['nodes/**.rb'].each { |node| require node }

---- inner
	const = 0
	def self.operators; @@operators; end
	@@operators = {
		:AND => const=const.next,
		:OR => const=const.next,
		:LT => const=const.next,
		:GT => const=const.next,
		:LTE => const=const.next,
		:GTE => const=const.next,
		:NE => const=const.next,
		:EQ => const=const.next,
		:MULTIPLY => const=const.next,
		:DIVIDE => const=const.next,
		:PLUS => const=const.next,
		:MINUS => const=const.next
	}

	def parse_file file
		load_file file
		do_parse
	end

---- footer
	if __FILE__ == $0
		program = FirstOrderLogic.new.parse_file(ARGV[0])
		puts program.to_s
	end
