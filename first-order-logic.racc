/* vim: set filetype=racc : */

class FirstOrderLogic

prechigh
	nonassoc NOT
	left AND
	left OR
	right IMPLIES
preclow

token OR XOR AND NOT
token BRACKET_OPEN BRACKET_CLOSE PAREN_OPEN PAREN_CLOSE
token TAUTOLOGY CONTRADICTION
token FOR_ALL THERE_EXISTS THERE_EXISTS_ONE
token COLON COMMA IMPLIES
token TERMINAL INTEGER IDENTIFIER
token NEWLINE

options no_result_var

start program

rule

program:
	/* nothing */                                { "" }
	| formulaList optNEWLINE                     { val.first.join("\n") } #{ Program.new *val.first; }
	;

formulaList:
	formula                                      { val }
	| formulaList NEWLINE formula                { val.first.push val.last }
	;

formula:
	predicate                                           { val.last }
	| PAREN_OPEN formula PAREN_CLOSE                    { '('+val[1]+')' } #{ ParentheticalExpresson.new val[1] }
	| TAUTOLOGY                                         { '⊤' } #{ Tautology.new }
	| CONTRADICTION                                     { '⊥' } #{ Contradiction.new }
	| formula predicateOperator formula                 { '('+val.join(' ')+')' } #{ Expression.new val[1], val.first, val.last }
	| formula IMPLIES formula                           { val.first + ' → ' + val.last } #{ Implication.new val.first val.last }
	| NOT formula                                       { '¬'+val.last } #{ val.last.not!; val.last }
	| FOR_ALL terminalList optCOLON formula             { '∀'+val[1].join('')+': '+val.last } #{ UniversalQuantifier.new val[1], val.last }
	| THERE_EXISTS_ONE terminalList optCOLON formula    { '∃!'+val[1].join('')+': '+val.last } #{ ExistentialQuantifier.new val[1], val.last, :one=>true }
	| THERE_EXISTS terminalList optCOLON formula        { '∃'+val[1].join('')+': '+val.last } #{ ExistentialQuantifier.new val[1], val.last }
	;

predicate:
	IDENTIFIER BRACKET_OPEN index BRACKET_CLOSE         { val.first+'['+val[2].join(',')+']' } #{ Predicate.new val.first, val[2] }
	;

index:
	terminalList              { val.last }
	| argList                 { val.last }
	;

argList:
	argListValue                   { val }
	| argList COMMA argListValue   { val.first.push val.last }
	;

argListValue:
	predicate                 { val.last }
	| TERMINAL                { val.last }
	| INTEGER                 { val.last.to_i }
	;

terminalList:
	TERMINAL                  { val }
	| terminalList TERMINAL   { val.first.push val.last }
	;

predicateOperator:
    AND                       { '∧' } #{ @@operators[:AND] }
	| XOR                     { '⊕' } #{ @@operators[:XOR] }
	| OR                      { '∨' } #{ @@operators[:OR] }
	;

optCOLON:   /* nothing */ { false } | COLON   { val.first } ;
optCOMMA:   /* nothing */ { false } | COMMA   { val.first } ;
optNEWLINE: /* nothing */ { false } | NEWLINE { val.first } ;

end

---- header
	require 'first-order-logic.rex.rb'
	Dir['nodes/**.rb'].each { |node| require node }

---- inner
	const = 0
	def self.operators; @@operators; end
	@@operators = {
		:AND => const=const.next,
		:XOR => const=const.next,
		:OR => const=const.next,
	}

	def parse_file file
		load_file file
		do_parse
	end

---- footer
	if __FILE__ == $0
		puts File.read(ARGV[0])
		program = FirstOrderLogic.new.parse_file(ARGV[0])
		puts program.to_s
	end
