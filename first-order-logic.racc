/* vim: set filetype=racc : */

class FirstOrderLogic

prechigh
	nonassoc NOT
	left AND
	left OR
	right IMPLIES
preclow

token OR XOR AND NOT
token BRACKET_OPEN BRACKET_CLOSE BRACE_OPEN BRACE_CLOSE PAREN_OPEN PAREN_CLOSE
token TAUTOLOGY CONTRADICTION
token FOR_ALL THERE_EXISTS THERE_EXISTS_ONE
token COLON COMMA IMPLIES
token FREE_VARIABLE INTEGER IDENTIFIER
token NEWLINE

options no_result_var

start program

rule

program:
	/* nothing */                                { "" }
	| formulaList optNEWLINE                     { val.first.join("\n") } #{ Program.new *val.first; }
	;

formulaList:
	formula                                      { val }
	| formulaList NEWLINE formula                { val.first.push val.last }
	;

formula:
	predicate                                           { val.last }
	| TAUTOLOGY                                         { '⊤' } #{ Tautology.new }
	| CONTRADICTION                                     { '⊥' } #{ Contradiction.new }
	| formula2 predicateOperator formula2               { '('+val.join(' ')+')' } #{ Expression.new val[1], val.first, val.last }
	| formula2 IMPLIES formula2                         { val.first + ' → ' + val.last } #{ Implication.new val.first val.last }
	| NOT formula2                                      { '¬'+val.last } #{ val.last.not!; val.last }
	| FOR_ALL index quantifierBody                      { '∀'+val[1]+': '+val.last } #{ UniversalQuantifier.new val[1], val.last }
	| THERE_EXISTS_ONE index quantifierBody             { '∃!'+val[1]+': '+val.last } #{ ExistentialQuantifier.new val[1], val.last, :one=>true }
	| THERE_EXISTS index quantifierBody                 { '∃'+val[1]+': '+val.last } #{ ExistentialQuantifier.new val[1], val.last }
	;

formula2:
	formula                                             { val.last }
	| PAREN_OPEN formula PAREN_CLOSE                    { '('+val[1]+')' } #{ ParentheticalExpresson.new val[1] }
	;

quantifierBody:
	optCOLON formula2                                   { val.last }
	| BRACE_OPEN formula BRACE_CLOSE                    { val[1] }

predicate:
	IDENTIFIER index                                    { val.first+val.last } #{ Predicate.new val.first, val[2] }
	;

index:
	BRACKET_OPEN argList BRACKET_CLOSE                  { '['+val[1].join(',')+']' }
	| argListValue                                      { val.last }
	;

argList:
	argListValue                   { val }
	| argList COMMA argListValue   { val.first.push val.last }
	;

argListValue:
	predicate                 { val.last }
	| FREE_VARIABLE           { val.last }
	| INTEGER                 { val.last.to_i }
	;

predicateOperator:
    AND                       { '∧' } #{ @@operators[:AND] }
	| XOR                     { '⊕' } #{ @@operators[:XOR] }
	| OR                      { '∨' } #{ @@operators[:OR] }
	;

optCOLON:   /* nothing */ { false } | COLON   { val.first } ;
#optCOMMA:   /* nothing */ { false } | COMMA   { val.first } ;
optNEWLINE: /* nothing */ { false } | NEWLINE { val.first } ;

end

---- header
	require 'first-order-logic.rex.rb'
	Dir['nodes/**.rb'].each { |node| require node }

---- inner
	const = 0
	def self.operators; @@operators; end
	@@operators = {
		:AND => const=const.next,
		:XOR => const=const.next,
		:OR => const=const.next,
	}

	def parse_file file
		load_file file
		do_parse
	end

---- footer
	if __FILE__ == $0
		puts File.read(ARGV[0])
		program = FirstOrderLogic.new.parse_file(ARGV[0])
		puts '---------------------'
		puts program.to_s
	end
