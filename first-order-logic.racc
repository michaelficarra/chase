/* vim: set filetype=racc : */

class FirstOrderLogic

prechigh
	nonassoc NOT
	left AND
	left OR
	right IMPLIES
preclow

token OR AND NOT
token BRACKET_OPEN BRACKET_CLOSE BRACE_OPEN BRACE_CLOSE PAREN_OPEN PAREN_CLOSE
token TAUTOLOGY CONTRADICTION
token FOR_ALL THERE_EXISTS THERE_EXISTS_ONE
token COLON COMMA IMPLIES
token FREE_VARIABLE INTEGER IDENTIFIER
token NEWLINE

options no_result_var

start program

rule

program
	: /* nothing */                         { "" }
	| formulaList optNEWLINE                { val.first.join("\n") } #{ Program.new *val.first; }
	;

formulaList
	: formula                               { val }
	| formulaList NEWLINE formula           { val.first.push val.last }
	;

formula
	: expr
	| expr IMPLIES expr                         { val.first + ' → ' + val.last } #{ Implication.new val.first val.last }
	| FOR_ALL index quantifierBody              { '∀'+val[1]+val.last } #{ UniversalQuantifier.new val[1], val.last }
	| THERE_EXISTS_ONE index quantifierBody     { '∃!'+val[1]+val.last } #{ ExistentialQuantifier.new val[1], val.last, :one=>true }
	| THERE_EXISTS index quantifierBody         { '∃'+val[1]+val.last } #{ ExistentialQuantifier.new val[1], val.last }
	;

expr: exprOR ;

exprOR
	: exprAND
	| exprOR OR exprOR                      { val.join(' ') } #{ Expression.new val[1], val.first, val.last }
	;

exprAND
	: exprValue
	| exprAND AND exprAND                   { '('+val.join(' ')+')' } #{ Expression.new val[1], val.first, val.last }
	;

exprValue
	: predicate
	| PAREN_OPEN formula PAREN_CLOSE        { '('+val[1]+')' } #{ ParentheticalExpresson.new val[1] }
	| TAUTOLOGY                             { val.last } #{ Tautology.new }
	| CONTRADICTION                         { val.last } #{ Contradiction.new }
	| NOT exprValue                         { '¬'+val.last } #{ val.last.not!; val.last }
	;

quantifierBody
	: optCOLON formula                      { ': '+val.last }
	| BRACE_OPEN formula BRACE_CLOSE        { '{ '+val[1]+' }' }
	;

predicate: IDENTIFIER index                 { val.first+val.last } #{ Predicate.new val.first, val[2] } ;

index
	: BRACKET_OPEN argList BRACKET_CLOSE    { val[1].length > 1 ? '['+val[1].join(',')+']' : val[1][0] }
	| argListValue
	;

argList
	: argListValue                          { val }
	| argList COMMA argListValue            { val.first.push val.last }
	;

argListValue
	: predicate
	| FREE_VARIABLE
	| INTEGER
	;

optCOLON:   /* nothing */ { false } | COLON   { val.first } ;
optNEWLINE: /* nothing */ { false } | NEWLINE { val.first } ;

end

---- header
	require 'first-order-logic.rex.rb'
	Dir['nodes/**.rb'].each { |node| require node }

---- inner
	const = 0
	def self.operators; @@operators; end
	@@operators = {
		:AND => const=const.next,
		:XOR => const=const.next,
		:OR => const=const.next,
	}

	def parse_file file
		load_file file
		do_parse
	end

---- footer
	if __FILE__ == $0
		puts File.read(ARGV[0])
		program = FirstOrderLogic.new.parse_file(ARGV[0])
		puts '---------------------'
		puts program.to_s
	end
