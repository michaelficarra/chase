#/* vim: set filetype=racc : */

class FirstOrderLogic

prechigh
	nonassoc NOT
	left MULTIPLY DIVIDE
	left ADD SUBTRACT
	right EQ
preclow

token FACTS RULES CHASE
token LT EQ GT GTE LTE NE
token PLUS MINUS MULTIPLY DIVIDE OR AND NOT
token BRACE_OPEN BRACE_CLOSE PAREN_OPEN PAREN_CLOSE
token FOR_ALL THERE_EXISTS EMPTY_SET
token COLON COMMA SEMICOLON IMPLIES
token PREDICATE IDENTIFIER
token NEWLINE

options no_result_var

start program

rule

program:
	/* nothing */             { Program.new }
	| statementList           { Program.new val.first; }
	;

statementList:
	statement semicolonOrNewline                    { [ Statement.new val.first ] }
	| statementList statement semicolonOrNewline    { val.pop; val.first.push val.last }
	;

statement:
	/* factDefinitionStatement */
	FACTS IDENTIFIER COLON optNEWLINE factList
	/*{ factList = val.pop; factList = factList.length>0 ? '{ '+factList.join(', ')+' }' : 'âˆ…'; val.reject{|s|s==''}.join(' ')+' '+factList }*/
	{ Assignment.new val[1], val.last }
	| /* ruleDefinitionStatement */
	RULES IDENTIFIER COLON optNEWLINE BRACE_OPEN optNEWLINE ruleList optNEWLINE BRACE_CLOSE
	/*{ ruleList = val[6].collect{|s|"\t"+s+",\n"}; val[0..3].reject{|s|s==''}.join(' ')+" {\n"+ruleList.join('')+'}' }*/
	{ Assignment.new val[1], val[6] }
	| /* chaseStatement */
	CHASE identifierList                      { ChaseStatement.new *val.last }
	;

factList:
	EMPTY_SET                                 { [] }
	| BRACE_OPEN predicateList BRACE_CLOSE    { val[1] }
	;

predicateList:
	predicate                                 { val }
	| predicateList predicate                 { val.first.push val.last }
	;

identifierList:
	IDENTIFIER                                { val }
	| identifierList COMMA IDENTIFIER         { val.first.push val.last }
	;

ruleList:
	rule                                      { [ Rule.new val.first ] }
	| ruleList commaOrNewline rule            { val.first.push val.last }
	;

rule:
	/* existentialRule */
	THERE_EXISTS optCOLON predicateExpression    { ExistentialRule.new val.first, val.last }
	| /* truthStatement */
	FOR_ALL COLON truthStatementBody             { TruthStatement.new val.first, val.last } 
	;

truthStatementBody:
	predicateExpression                       { PredicateExpression.new val.first }
	| /* predicateImplication */
	predicateExpression IMPLIES expression    { PredicateImplication.new val.first, val.last }
	;

predicateExpression:
	predicate                                              { val.first }
	| optNOT PAREN_OPEN predicateExpression PAREN_CLOSE    { val[2].not if val[0]; val[2] }
	| predicateExpression AND predicateExpression          { PredicateExpressionAND.new val.first, val.last }
	| predicateExpression OR predicateExpression           { PredicateExpressionOR.new val.first, val.last }
	;

expression:
	predicateExpression                                         { val.first }
	| terminalExpression                                        { val.first }
	;

terminalExpression:
	IDENTIFIER                                                  { TerminalExpression.new val.first }
	| optNOT PAREN_OPEN terminalExpression PAREN_CLOSE          { val[2].not if val[0]; val[2] }
	| /* terminalEquality */
	terminalExpression EQ terminalExpression                    { TerminalExpressionEquality.new val.first, val.last }
	| /* terminalInequality */
	terminalExpression inequalityOperator terminalExpression    { TerminalExpressionInequality.new *val  }
	| terminalExpression MULTIPLY terminalExpression            { TerminalExpressionMultiply.new val.first, val.last }
	| terminalExpression DIVIDE terminalExpression              { TerminalExpressionDivide.new val.first, val.last }
	| terminalExpression PLUS terminalExpression                { TerminalExpresionPlus.new val.first, val.last }
	| terminalExpression MINUS terminalExpression               { TerminalExpresionMinus.new val.first, val.last }
	;

inequalityOperator:
	LT                        { @@constants[:LT] }
	| GT                      { @@constants[:GT] }
	| LTE                     { @@constants[:LTE] }
	| GTE                     { @@constants[:GTE] }
	| NE                      { @@constants[:NE] }
	;

predicate:
	PREDICATE                 { Predicate.new val.first[:symbol], val.first[:terminals] }
	| NOT predicate           { val[1].not; val[1] }
	;

optNOT:     /* nothing */ { false } | NOT     { true } ;
optCOLON:   /* nothing */ { false } | COLON   { true } ;
optNEWLINE: /* nothing */ { false } | NEWLINE { true } ;

commaOrNewline:
	NEWLINE                   { val.first }
	| COMMA optNEWLINE        { val.first }
	;

semicolonOrNewline:
	NEWLINE                   { '' }
	| SEMICOLON optNEWLINE    { val.first }
	;

end

---- header
	require 'first-order-logic.rex.rb'

---- inner

	const = 0
	@@operators = {
		:NOT => const++,
		:LT => const++,
		:GT => const++,
		:LTE => const++,
		:GTE => const++,
		:NE => const++
	}

	def parse_file file
		load_file file
		do_parse
	end

---- footer
	if __FILE__ == $0
		FirstOrderLogic.new.parse_file(ARGV[0])
	end
