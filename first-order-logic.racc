#/* vim: set filetype=racc : */

class FirstOrderLogic

prechigh
	nonassoc NOT
	left MULTIPLY DIVIDE
	left ADD SUBTRACT
	right EQ
preclow

token FACTS RULES CHASE
token LT EQ GT GTE LTE NE
token PLUS MINUS MULTIPLY DIVIDE OR AND NOT
token BRACE_OPEN BRACE_CLOSE PAREN_OPEN PAREN_CLOSE
token FOR_ALL THERE_EXISTS EMPTY_SET
token COLON COMMA SEMICOLON IMPLIES
token PREDICATE IDENTIFIER
token NEWLINE

options no_result_var

start program

rule

program:
	/* nothing */             { puts "" }
	| statementList           { puts val.first.join(";\n"); }
	;

statementList:
	statement semicolonOrNewline                    { [val.first] }
	| statementList statement semicolonOrNewline    { val.pop; val.first.push val.last }
	;

statement:
	/* factDefinitionStatement */
	FACTS IDENTIFIER COLON optNEWLINE factList
	{ factList = val.pop; factList = factList.length>0 ? '{ '+factList.join(', ')+' }' : '∅'; val.reject{|s|s==''}.join(' ')+' '+factList }
	| /* ruleDefinitionStatement */
	RULES IDENTIFIER COLON optNEWLINE BRACE_OPEN optNEWLINE ruleList optNEWLINE BRACE_CLOSE
	{ ruleList = val[6].collect{|s|"\t"+s+",\n"}; val[0..3].reject{|s|s==''}.join(' ')+" {\n"+ruleList.join('')+'}' }
	| /* chaseStatement */
	CHASE identifierList                      { val.first+' '+val.last.join(', ') }
	;

factList:
	EMPTY_SET                                 { [] }
	| BRACE_OPEN predicateList BRACE_CLOSE    { val.first + ' ' + val[1] + val[2].join(', ') + val[3] }
	;

predicateList:
	predicate                                 { val }
	| predicateList predicate                 { val.first.push val.last }
	;

identifierList:
	IDENTIFIER                                { val }
	| identifierList COMMA IDENTIFIER         { val.first.push val.last }
	;

ruleList:
	rule                                      { val }
	| ruleList commaOrNewline rule            { val.first.push val.last }
	;

rule:
	/* existentialRule */
	THERE_EXISTS optCOLON predicateExpression    { val[0]='∃'+val.first.join(''); val.join(' ') }
	| /* truthStatement */
	FOR_ALL COLON truthStatementBody             { val[0]='∀'+val.first.join(''); val.join(' ') }
	;

truthStatementBody:
	predicateExpression                       { val.first }
	| /* predicateImplication */
	predicateExpression IMPLIES expression    { val.join(' ') }
	;

predicateExpression:
	predicate                                              { val.first }
	| optNOT PAREN_OPEN predicateExpression PAREN_CLOSE    { val.join('') }
	| predicateExpression AND predicateExpression          { '('+val.join(' ')+')' }
	| predicateExpression OR predicateExpression           { val.join(' ') }
	;

expression:
	predicateExpression                                         { val.first }
	| terminalExpression                                        { val.first }
	;

terminalExpression:
	IDENTIFIER                                                  { val.first }
	| optNOT PAREN_OPEN terminalExpression PAREN_CLOSE          { val.pop+val.join(' ') }
	| /* terminalEquality */
	terminalExpression EQ terminalExpression                    { val.join(' ') }
	| /* terminalInequality */
	terminalExpression inequalityOperator terminalExpression    { val.join(' ') }
	| terminalExpression MULTIPLY terminalExpression            { '('+val.join('')+')' }
	| terminalExpression DIVIDE terminalExpression              { '('+val.join('')+')' }
	| terminalExpression PLUS terminalExpression                { val.join(' ') }
	| terminalExpression MINUS terminalExpression               { val.join(' ') }
	;

inequalityOperator:
	LT                        { val.first }
	| GT                      { val.first }
	| LTE                     { val.first }
	| GTE                     { val.first }
	| NE                      { val.first }
	;

predicate:
	PREDICATE                 { val.first[:symbol]+val.first[:terminals].join('') }
	| NOT PREDICATE           { val.join('') }
	;

optNOT:     /* nothing */ { '' } | NOT     { val.first } ;
optCOLON:   /* nothing */ { '' } | COLON   { val.first } ;
optNEWLINE: /* nothing */ { '' } | NEWLINE { val.first } ;

commaOrNewline:
	NEWLINE                   { val.first }
	| COMMA optNEWLINE        { val.first }
	;

semicolonOrNewline:
	NEWLINE                   { '' }
	| SEMICOLON optNEWLINE    { val.first }
	;

end

---- header
	require 'first-order-logic.rex.rb'

---- inner
	def parse_file file
		load_file file
		do_parse
	end

---- footer
	if __FILE__ == $0
		FirstOrderLogic.new.parse_file(ARGV[0])
	end
