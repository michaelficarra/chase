/* vim: set filetype=racc : */

class FirstOrderLogic

prechigh
	nonassoc NOT
	left MULTIPLY DIVIDE
	left ADD SUBTRACT
	right EQ
preclow

token FACTS RULES CHASE
token LT GT GTE LTE NE EQ
token PLUS MINUS MULTIPLY DIVIDE OR XOR AND NOT
token BRACE_OPEN BRACE_CLOSE PAREN_OPEN PAREN_CLOSE
token TAUTOLOGY CONTRADICTION
token FOR_ALL THERE_EXISTS EMPTY_SET
token COLON COMMA SEMICOLON IMPLIES
token PREDICATE IDENTIFIER
token NEWLINE

options no_result_var

start program

rule

program:
	/* nothing */                                   { Program.new }
	| statementList                                 { Program.new *val.first; }
	;

statementList:
	statement semicolonOrNewline                    { val.pop; val }
	| statementList statement semicolonOrNewline    { val.pop; val.first.push val.last }
	;

statement:
	/* factDefinitionStatement */
	FACTS IDENTIFIER assignmentOperator optNEWLINE factList
	{ FactDefinitionStatement.new( val[1], FactList.new(*val.last) ) }
	| /* ruleDefinitionStatement */
	RULES IDENTIFIER assignmentOperator optNEWLINE BRACE_OPEN optNEWLINE ruleList optNEWLINE BRACE_CLOSE
	{ RuleDefinitionStatement.new( val[1], RuleList.new(*val[6]) ) }
	| /* chaseStatement */
	CHASE identifierList                         { ChaseStatement.new *val.last }
	;

assignmentOperator:
	COLON optEQ                                  { val.select{|_| _ } }
	| EQ                                         { val.first }
	;

factList:
	EMPTY_SET                                    { [] }
	| BRACE_OPEN predicateList BRACE_CLOSE       { val[1] }
	;

predicateList:
	predicate                                    { val }
	| predicateList predicate                    { val.first.push val.last }
	;

predicate:
	PREDICATE                                    { Predicate.new val.first[:symbol], val.first[:terminals] }
	| NOT predicate                              { val.last.not; val.last }
	;

identifierList:
	IDENTIFIER                                   { val }
	| identifierList COMMA IDENTIFIER            { val.first.push val.last }
	;

ruleList:
	rule                                         { val }
	| ruleList commaOrNewline rule               { val.first.push val.last }
	;

rule:
	existentialQuantifier                        { val.first }
	| universalQuantifier                        { val.first }
	;

existentialQuantifier:
	THERE_EXISTS optCOLON predicateList          { ExistentialQuantifier.new val.first, val.last }
	;

universalQuantifier:
	FOR_ALL optCOLON universalQuantifierBody     { UniversalQuantifier.new val.first, val.last }
	;

universalQuantifierBody:
	universalQuantifier                          { val.first }
	existentialQuantifier                        { val.first }
	| predicateExpression predicateImplication   { if val.last then PredicateImplication.new val.first, val.last else val.first end }
	;

predicateImplication:
	/* nothing */                                { false }
	| IMPLIES expression                         { val.last }
	;

expression:
	predicateExpression                          { val.first }
	| terminalExpression                         { val.first }
	| expressionValue                            { val.first }
	;

expressionValue:
	PAREN_OPEN expression PAREN_CLOSE            { val[1] }
	| TAUTOLOGY                                  { Tautology.new }
	| CONTRADICTION                              { Contradiction.new }
	| NOT expressionValue                        { val.last.not; val.last }
	;

predicateExpression:
	predicateExpressionValue                     { val.first }
	| predicateExpressionValue predicateOperator predicateExpressionValue
	{ PredicateExpression.new val[1], val.first, val.last }
	;

predicateExpressionValue:
	PREDICATE                                                      { Predicate.new val.first[:symbol], val.first[:terminals] }
	| PAREN_OPEN predicateExpression PAREN_CLOSE                   { val[1] }
	| NOT predicateExpressionValue                                 { val.last.not; val.last }
	;

predicateOperator:
    AND                       { @@operators[:AND] }
	| XOR                     { @@operators[:XOR] }
	| OR                      { @@operators[:OR] }
	;

terminalExpression:
	terminalExpressionValue                      { val.first }
	| terminalExpressionValue terminalOperator terminalExpressionValue
	{ TerminalExpression.new val[1], val.first, val.last }
	;

terminalExpressionValue:
	IDENTIFIER                                                     { Terminal.new val.first }
	| PAREN_OPEN terminalExpression PAREN_CLOSE                    { val[1] }
	| NOT terminalExpressionValue                                  { val.last.not; val.last }
	;

terminalOperator:
	LT                        { @@operators[:LT] }
	| GT                      { @@operators[:GT] }
	| LTE                     { @@operators[:LTE] }
	| GTE                     { @@operators[:GTE] }
	| NE                      { @@operators[:NE] }
	| EQ optEQ                { @@operators[:EQ] }
	| MULTIPLY                { @@operators[:MULTIPLY] }
	| DIVIDE                  { @@operators[:DIVIDE] }
	| PLUS                    { @@operators[:PLUS] }
	| MINUS                   { @@operators[:MINUS] }
	;

optEQ:      /* nothing */ { false } | EQ      { val.first } ;
optCOLON:   /* nothing */ { false } | COLON   { val.first } ;
optCOMMA:   /* nothing */ { false } | COMMA   { val.first } ;
optNEWLINE: /* nothing */ { false } | NEWLINE { val.first } ;

commaOrNewline:
	NEWLINE optCOMMA optNEWLINE          { val.select{|_| _ } }
	| COMMA optNEWLINE                   { val.select{|_| _ } }
	;

semicolonOrNewline:
	NEWLINE                   { val.first }
	| SEMICOLON optNEWLINE    { val.select{|_| _ } }
	;

end

---- header
	require 'first-order-logic.rex.rb'
	Dir['nodes/**.rb'].each { |node| require node }

---- inner
	const = 0
	def self.operators; @@operators; end
	@@operators = {
		:AND => const=const.next,
		:XOR => const=const.next,
		:OR => const=const.next,
		:LT => const=const.next,
		:GT => const=const.next,
		:LTE => const=const.next,
		:GTE => const=const.next,
		:NE => const=const.next,
		:EQ => const=const.next,
		:MULTIPLY => const=const.next,
		:DIVIDE => const=const.next,
		:PLUS => const=const.next,
		:MINUS => const=const.next
	}

	def parse_file file
		load_file file
		do_parse
	end

---- footer
	if __FILE__ == $0
		program = FirstOrderLogic.new.parse_file(ARGV[0])
		puts program.to_s
	end
